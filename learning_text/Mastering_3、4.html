<html>
<head>
  <title>Evernote Export</title>
  <basefont face="等线" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 等线;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="589"/>

<div>
<span><div><span style="font-size: 11pt;">Classification and Regression with K-Nearest Neighbors</span></div><div><span style="font-size: 11pt;">章节3</span></div><div><span style="font-size: 11pt;">1、page121、MSE和page95 SSres的公式相比，就只是多除了n？但是这样的话为什么写法不一样呢？</span></div><div><span style="font-size: 11pt;">2、scaling features 标度特性</span></div><div><span style="font-size: 11pt;">被标准化了的数据，模型能够预测的更好</span></div><div><span style="font-size: 11pt;">page124</span></div><div><span style="font-size: 11pt;">用StandardScaler fit transform之后的结果和书上的不一样：第0列的数据不一样，而第1列的数据一样，不知道是哪里的问题？</span></div><div><span style="font-size: 11pt;">计算方法：用每个数据减去平均数，然后再除以（总体n的）标准差，注意和（样本的）标准差的区别。</span></div><div><span style="font-size: 11pt;">得出的结论，和单位有关的量，最好做标准化处理！因为可以提高模型的准确率。</span></div><div><span style="font-size: 11pt;">KNN是惰性学习器，并且是五参数模型，它不从训练集的固定的参数值预测，而是存储所有的训练集实例，使用距离这些实例最近的值去预测。</span></div><div><br/></div><div><span style="font-size: 11pt;">Feature Extraction</span></div><div><span style="font-size: 11pt;">章节4</span></div><div><span style="font-size: 11pt;">page130</span></div><div><span style="font-size: 11pt;">也许用整数代表城市，例如用零代表New York，用1代表San Francisco，用2代表Chapel Hill，这样直觉上更好理解。但是这种人工编码的信息导致的问题是，被代表的城市生成了真实世界中不存在的顺序。促进了它们的比较，但实际上没有任何意义。没有自然顺序使得Chapel Hill比San Francisco多1。</span></div><div><span style="font-size: 11pt;">page132</span></div><div><span style="font-size: 11pt;">一个特征向量的方差为1，那么它们特征的变量就具有相同的重要性等级，特征将支配学习算法，防止它从其它的变量中学习。</span></div><div><span style="font-size: 11pt;">当数据没有标准化（归一化）的时候，一些学习算法归集最优参数将变得很慢。</span></div><div><span style="font-size: 11pt;">page136</span></div><div><span style="font-size: 11pt;">单词包模型为文档钟的每一个感兴趣的单词生成一个特征。单词包模型被这种直觉激发：包含相似单词的文档经常含有相似的意思。单词包模型能够被高效的进行文档分类，当它编码时取回尽管被限制的信息。文档的集合被称之为语料集。</span></div><div><span style="font-size: 11pt;">向量维度：组成特征向量的元素的个数，被称作向量维度。</span></div><div><span style="font-size: 11pt;">page140</span></div><div><span style="font-size: 11pt;">第二个策略是移除在语料集中大多数文档中都存在的单词。这些单词被称之为停止词，经常包括数量词，例如the、a、an，介词：do、be、will，前置词：on、around、beneath。停止词是通过文档的语法意义产生作用，而不是它们本身的含义。</span></div><div><span style="font-size: 11pt;">page142</span></div><div><span style="font-size: 11pt;">一个大的语料集经过过滤之后仍然含有成千上万的唯一单词。两个相似的策略去减少维度被称之为stemming、lemmatization</span></div><div><span style="font-size: 11pt;">上面的文档意思相同，但是它们的特征向量没有任何相同的元素。所有的文档包含动词ate的变行形式和sandwich这个词。这些相似应该被反映在特征向量中。Lemmatization</span></div><div><span style="font-size: 11pt;">page145</span></div><div><span style="font-size: 11pt;">有一点儿的代码可以变得更简单，书中的代码：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 11pt;">np.array(vectorizer.fit_transform(corpus).todense())[0]</font></span></div></div><div><span style="font-size: 11pt;">修改后的代码：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 11pt;">vectorizer.fit_transform(corpus).toarray()[0]</font></span></div></div><div><span style="font-size: 11pt;">注意CountVectorizer的二进制参数被忽略了，它的默认值是False，当产生它返回原生单词组的频次而不是二进制的频次。</span></div><div><span style="font-size: 11pt;">很多单词也许出现了相同的频次在两个文档中，但是文档仍然不相似，如果一个文档比另一个文档大几倍的话。</span></div><div><span style="font-size: 11pt;">归一化和对数划分单词频数能够代表文档中单词的频次，当聚合不同文档长度的影响时。但是另外一个问题仍然存在。</span></div><div><span style="font-size: 11pt;">page150</span></div><div><span style="font-size: 11pt;">单词嵌入</span></div><div><span style="font-size: 11pt;">单词嵌入是这些文档的代表：聚合一些单词包模型的短处。不像单词包模型用标量（实量）代表每一个口令，单词嵌入用向量。这些向量经常是稠密的，经常有50~500个维度。</span></div><div><span style="font-size: 11pt;">在一个有效序列中用相似意义的单词替换一个单词将很可能导致一个有效的序列。如果‘the small cat is grumpy’和‘the small kitten is grumpy’都是有效的序列，模型将表示‘cat’和‘kitten’用相似的向量。用一个无关的单词在一个有效的序列中替换一个单词，很可能将导致一个无效的序列，并且需要学习算法去提高嵌入函数的参数。序列‘the small cat is grumpy’和‘the small kitten is grumpy’除了一个单词外，其它都是相同的。如果分类器学习到后者是无效的，那么代表‘cat’和‘kitten’的向量必须不同。通过学习去分类无效口令序列，模型生成嵌入式函数为有相似意思的单词生成相似的向量。表示同义词的向量应该相似，例如‘small’、‘tiny’，对等的短语，例如‘UNC’、‘Duke’。表示反义词的向量除了一个或者几乎很少的维度外其它都应该相似，例如：‘big’、‘small’。</span></div><div><span style="font-size: 11pt;">设想一个包含有‘dog was happy’文档的语料集。也假设这些语料集中的单词不包含口令‘puppy’、‘sad’。一个柔软的分析模型在一个单词包上训练对这些语料集将是无力的，当他计数一个短语，例如‘the dog was sad’时。</span></div><div><span style="font-size: 11pt;">训练一个模型就像我们的例子序列在一个巨大的语料集中分类将非常的消耗计算，但是结果单词嵌入将适用在很多范围。由于这样的原因，预先训练单词前次时非常普遍的。</span></div><div><span style="font-size: 11pt;">例子是一个1.5GB的压缩文件，而解压缩之后达到了3.4G，这个模型需要的内存是大于8G的。作者举的这个例子也是让人醉了。所以在这一章中我只学到了一个：有gensim这个包。</span></div><div><span style="font-size: 11pt;">page154</span></div><div><span style="font-size: 11pt;">从图片中提取特征</span></div><div><span style="font-size: 11pt;">计算机视觉是计算化的人工进程和理解图片的研究和设计。这些人工制品雇佣了机器学习。</span></div><div><span style="font-size: 11pt;">page156</span></div><div><span style="font-size: 11pt;">从像素的强度中提取特征</span></div><div><span style="font-size: 11pt;">数字图片经常是光栅、橡塑图，将颜色映射到网格坐标上。也就是图片能够被当作一个矩阵，矩阵中的每个元素代表一种颜色。图片的基础特征能够被建立通过重置矩阵将其变成向量，通过重新把它所有的行连接在一起。光学字符识别是经典的机器学习问题。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>digits.images[0].reahspe(-1,64) </div></div><div>虽然上面生成的结果是正确的，但是有更好的写法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>digits.images[0].reshape(1,-1)</div></div><div><br/></div></span>
</div></body></html> 